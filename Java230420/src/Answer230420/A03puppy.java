package Answer230420;

import java.util.*;
public class A03puppy {
//돌아다니는 강아지 찾기
	public int solution(int[][] board){	//메소드 선언
		int n = board.length;	//받아온 배열의 크기
		int[] dx = {-1, 0, 1, 0};
		int[] dy = {0, 1, 0, -1};
		//각각 12시, 3시, 6시, 9시 방향으로 90도 회전할 때 좌표에 더해지는 값
		int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
		//현수좌표 x1,y1 강아지좌표 x2,y2
		for(int i = 0; i < n; i++) {
			for(int j = 0; j < n; j++) {
				if(board[i][j] == 2) {	//i,j에 현수가 있으면
					x1 = i;				//좌표값 부여
					y1 = j;
				}
				if(board[i][j] == 3) {	//i,j에 강아지가 있으면
					x2 = i;				//좌표값 부여
					y2 = j;
				}
			}
		}
		int d1 = 0, d2 = 0, count = 0;
		//현수 방향 12시, 강아지 방향 12시, 시간min
		while(count < 10000) {	//10000분이 넘으면 멈춤
			count++;	//+1분
			int nx1 = x1 + dx[d1];
			int ny1 = y1 + dy[d1];
			int nx2 = x2 + dx[d2];
			int ny2 = y2 + dy[d2];
			//현수와 강아지가 한칸 전진했을 때 어떤 좌표값이 나오는지 nx1,ny1 nx2,ny2로 가정한다
			boolean flag1 = true, flag2 = true;
			//현수와 강아지 각각의 움직임을 위해 논리자료형을 이용한다
			if(nx1 < 0 || nx1 >= n || ny1 < 0 || ny1 >= n || board[nx1][ny1] == 1) {
				//현수 한칸 전진한 좌표가 배열의 범위를 벗어나거나 벽으로 막혀있을 때
				d1 = (d1 + 1) % 4;	//현수 시계방향 전환
				flag1 = false;
			}
			if(nx2 < 0 || nx2 >= n || ny2 < 0 || ny2 >= n || board[nx2][ny2] == 1){
				//강아지 한칸 전진한 좌표가 배열의 범위를 벗어나거나 벽으로 막혀있을 때
				d2 = (d2 + 1) % 4;	//강아지 시계방향 전환
				flag2 = false;
			}
			if(flag1 == true) {	//현수 방향전환하지 않았을 때
				x1 = nx1;		//현수 전진
				y1 = ny1;
			}
			if(flag2 == true) {	//강아지 방향전환하지 않았을 때
				x2 = nx2;		//강아지 전진
				y2 = ny2;
			}
			if(x1 == x2 && y1 == y2) break;
			//현수의 좌표와 강아지의 좌표가 동일하면 끝
		}
		if(count >= 10000) return 0;	//10000분이 되어도 못만나면 0 리턴
		return count;	//만났을 때 걸린 시간 리턴
	}

	public static void main(String[] args){
		A03puppy T = new A03puppy();
		//0 이동가능, 1 벽, 2 현수, 3 강아지
		int[][] arr1 = {{0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
			{0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
			{0, 0, 0, 1, 0, 0, 0, 1, 0, 0}, 
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
			{0, 0, 0, 1, 0, 0, 0, 2, 0, 0}, 
			{1, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
			{0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
			{0, 0, 0, 0, 0, 3, 0, 0, 0, 1}, 
			{0, 0, 0, 1, 0, 1, 0, 0, 0, 0}, 
			{0, 1, 0, 1, 0, 0, 0, 0, 0, 0}}; 
		System.out.println(T.solution(arr1));
		int[][] arr2 = {{1, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
			{0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
			{0, 0, 1, 1, 0, 0, 0, 1, 0, 0}, 
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
			{0, 0, 0, 1, 0, 1, 0, 0, 0, 0}, 
			{1, 0, 0, 0, 0, 0, 1, 0, 1, 0}, 
			{0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
			{0, 0, 1, 0, 0, 0, 0, 0, 2, 1}, 
			{0, 0, 0, 1, 0, 1, 0, 0, 0, 1}, 
			{0, 1, 0, 1, 0, 0, 0, 0, 0, 3}}; 
		System.out.println(T.solution(arr2));
	}
}